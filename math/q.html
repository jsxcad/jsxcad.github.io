<html>
 <head>
  <script src="./qrcodegen-v1.8.0-es6.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [[',,', ',,']] // Enable inline math delimiters
      }
    };
  </script>
  <style>
   .stamp {
     background-color: white;
     border: 2px solid white;
   }
   .sheet {
     position: absolute;
     top: 1em;
     bottom: 1em;
     width: 210mm;
     height: 278mm;
     overflow: hidden;
   }
   .column {
     height: 100%;
   }
   .left {
     top: 1em;
     bottom: 1em;
     position: absolute;
     height: 320mm;
     width: 105mm;
     left: 5mm;
     border: 1px black solid;
     padding: 1em;
     overflow: hidden;
   }
   .right {
     top: 1em;
     bottom: 1em;
     position: absolute;
     height: 320mm;
     width: 105mm;
     left: 120mm;
     border: 1px black solid;
     padding: 1em;
     overflow: hidden;
   }

   .generator {
     font-size: 0.5em;
     position: relative;
   }

   .problem {
     padding: 0;
     margin: 0;
   }

   .tooltip {
   }

   .tooltip .tooltiptext {
     display: none;
     visibility: hidden;
     width: 100%;
     background-color: black;
     color: #fff;
     padding: 5px 0;
     border-radius: 6px;

     /* Positioning */
     position: relative;
     z-index: 1;
     left: 0;
     top: 0;

     /* Optional: Fade-in transition */
     opacity: 0;
     transition: opacity 0.3s;
   }

   .tooltip:hover .tooltiptext {
     visibility: visible;
     display: block;
     opacity: 1;
   }
  </style>
 </head>
 <body>
  <div class="sheet" id="sheet">
    </div>
    <div class="left column" id="left">
    </div>
    <div class="right column" id="right">
    </div>
  </div>
  <script type="module">
    import * as IDB from 'https://cdnjs.cloudflare.com/ajax/libs/idb-keyval/6.2.1/compat.min.js';
    import { escapeHtml, loadProblems, loadTags, renderProblem, renderRuledLine, saveProblem } from './common.js';

    const problems = await loadProblems();
    const { limits, requiredTags } = await loadTags();

    const decodeSignature = (params) => {
      const s = params.get('s');
      if (s) {
        return s.split(',').map((string) => Number(string));
      } else {
        return [];
      }
    };

    const params = new URLSearchParams(document.location.search);
    const s = decodeSignature(params);

    const chooseProblem = (chosen, tagUses, problems) => {
      if (s.length > 0) {
        const id = s.shift();
        for (const problem of problems) {
          if (problem.id === id) {
            return problem;
          }
        }
      }
      let seen = 0;
      let chosenProblem;
      for (const problem of problems) {
        if (chosen.has(problem) || problem.note.isBlocked) {
          continue;
        }
        if (!problem.tags || problem.tags.length === 0) {
          continue;
        }
        let exclude = false;
        for (const tag of problem.tags) {
          const { limit = 1 } = limits[tag] === undefined ? {} : limits[tag];
          if (limit <= (tagUses.get(tag) || 0)) {
            exclude = true;
            break;
          }
        }
        if (exclude) {
          continue;
        }
        let hasRequiredTags = true;
        for (const tag of requiredTags) {
          if (!problem.tags.includes(tag)) {
            hasRequiredTags = false;
            break;
          }
        }
        if (!hasRequiredTags) {
          continue;
        }
        seen += 1;
        if (Math.random() * seen <= 1) {
          chosenProblem = problem;
        }
      }
      return chosenProblem;
    }

    const chosen = new Set();
    const tagUses = new Map();

    const signature = [];

    const problemByRender = new Map();

    let currentX = 0;
    let currentY = 0;

    document.addEventListener('mousemove', (event) => {
      currentX = event.clientX;
      currentY = event.clientY;
    });

    document.addEventListener('keydown', async (e) => {
      const { key } = e;
      let target = document.elementFromPoint(currentX, currentY);
      let problem;
      while (target) {
        problem = problemByRender.get(target);
        if (problem !== undefined) {
          break;
        }
        target = target.parentElement;
      }
      const note = problem.note;
      if (note.weight === undefined) {
        note.weight = 1;
      }
      switch (key) {
        case 'x':
          note.isBlocked = true;
          target.style.display = 'none';
          break;
        case 'g':
          note.weight *= 1.1;
          break;
        case 'b':
          note.weight *= 0.9;
          break;
      }
      await saveProblem(problem);
    }, true);

    const renderColumn = async (column) => {
      for (let nth = 0; nth < 7; nth++) {
        const problem = chooseProblem(chosen, tagUses, problems);
        if (problem === undefined) {
          continue;
        }
        const e = renderProblem(problem);
        column.appendChild(e);
        signature.push(problem.id);
        chosen.add(problem);
        for (const tag of problem.tags) {
          tagUses.set(tag, (tagUses.get(tag) || 0) + 1);
        }
        problemByRender.set(e, problem);
      }
    };

    const left = document.getElementById('left');
    const right = document.getElementById('right');

    await renderColumn(left);
    await renderColumn(right);

    {
      const payload = `https://jsxcad.js.org/math/q.html?s=${signature.join(',')}`;
      const qr = qrcodegen.QrCode.encodeText(payload, qrcodegen.QrCode.Ecc.MEDIUM);

      const toSvgString = (qr, border, lightColor, darkColor) => {
        if (border < 0)
            throw new RangeError("Border must be non-negative");
        let parts = [];
        for (let y = 0; y < qr.size; y++) {
            for (let x = 0; x < qr.size; x++) {
                if (qr.getModule(x, y))
                    parts.push(`M${x + border},${y + border}h1v1h-1z`);
            }
        }
        return `
          <svg width="64" height="64" viewBox="0 0 ${qr.size + border * 2} ${qr.size + border * 2}" stroke="none">
	    <rect width="100%" height="100%" fill="${lightColor}"/>
	    <path d="${parts.join(" ")}" fill="${darkColor}"/>
          </svg>`;
      };
      const svgText = toSvgString(qr, 5, 'white', 'black');
      const div = document.createElement('div');
      div.innerHTML = svgText;
      const svg = div.firstChild.nextSibling;
      const firstPassage = right.firstChild.nextSibling;
      firstPassage.insertBefore(svg, firstPassage.firstChild);
      svg.style.float = 'right';
      svg.style.zIndex = 10;
      svg.onclick = (e) => { window.location = payload; };
    }

    while (!MathJax.startup) {
      await new Promise(resolve => setTimeout(resolve, 10)); // Wait 10ms
    }

    await MathJax.startup.promise;
    await MathJax.typesetPromise();

  </script>
 </body>
</html>
