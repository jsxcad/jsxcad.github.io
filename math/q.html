<html>
 <head>
  <script src="./qrcodegen-v1.8.0-es6.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [[',,', ',,']] // Enable inline math delimiters
      }
    };
  </script>
  <style>
   .stamp {
     background-color: white;
     border: 2px solid white;
   }
   .sheet {
     position: absolute;
     top: 1em;
     bottom: 1em;
     width: 210mm;
     height: 278mm;
     overflow: hidden;
   }
   .column {
     height: 100%;
     display: grid;
     grid-template-columns: 1fr;
     grid-auto-rows: min-content;
     grid-gap: 1fr;
   }
   .left {
     top: 1em;
     bottom: 1em;
     position: absolute;
     height: 320mm;
     width: 105mm;
     left: 5mm;
     border: 1px black solid;
     padding: 1em;
     overflow: hidden;
   }
   .right {
     top: 1em;
     bottom: 1em;
     position: absolute;
     height: 320mm;
     width: 105mm;
     left: 120mm;
     border: 1px black solid;
     padding: 1em;
     overflow: hidden;
   }

   .generator {
     font-size: 0.5em;
     position: relative;
   }

   .problem {
     padding: 0;
     margin: 0;
   }

   .tooltip {
   }

   .tooltip .tooltiptext {
     display: none;
     visibility: hidden;
     width: 100%;
     background-color: black;
     color: #fff;
     padding: 5px 0;
     border-radius: 6px;

     /* Positioning */
     position: relative;
     z-index: 1;
     left: 0;
     top: 0;

     /* Optional: Fade-in transition */
     opacity: 0;
     transition: opacity 0.3s;
   }

   .tooltip:hover .tooltiptext {
     visibility: visible;
     display: block;
     opacity: 1;
   }
  </style>
 </head>
 <body>
  <div class="sheet" id="sheet">
    </div>
    <div class="left column" id="left">
    </div>
    <div class="right column" id="right">
    </div>
  </div>
  <script type="module">
    import * as IDB from 'https://cdnjs.cloudflare.com/ajax/libs/idb-keyval/6.2.1/compat.min.js';
    import { problems } from './problems.js';

    const loadNote = async (key) => {
      const value = await IDB.get(key);
      if (value === undefined) {
        return {};
      } else {
        return value;
      }
    };

    const saveNote = async (key, value) => IDB.set(key, value);

    const renderRuledLine = () => {
      const div = document.createElement('div');
      div.innerHTML = `
        <svg width="100%" height="30" viewBox="0 0 4 30" preserveAspectRatio="none">
          <path stroke="black" stroke-opacity="0.25" d="M 0 10 L 4 10"/>
          <path stroke="black" stroke-opacity="0.25" d="M 0 15 L 4 15"/>
          <path stroke="black" stroke-opacity="0.50" d="M 0 25 L 4 25"/>
          <path stroke="black" stroke-opacity="0.25" d="M 0 30 L 4 30"/>
        </svg>`;
      return div;
    }

    const renderProblem = ({ id = -1, generator, problem, solution, lines = 3 }) => {
      const div = document.createElement('div');
      div.classList.add('problem', 'tooltip');
      div.innerText = problem;
      for (let line = 0; line < lines; line++) {
        div.appendChild(renderRuledLine());
      }
      const span = document.createElement('div')
      span.innerText = generator;
      span.classList.add('generator');
      div.insertBefore(span, div.firstChild);
      const note = document.createElement('div');
      note.innerHTML = `${id}<br>${solution}`;
      note.classList.add('tooltiptext');
      div.appendChild(note);
      return div;
    };

    const kEligibleGenerators = new Set([
      'airplane-trivia',
      'arithmetic',
      'arithmetic-carry',
      'arithmetic-division',
      'arithmetic-multiplication',
      'bad-grammar',
      'bad-spelling',
      'definition-question',
      'gap-sentence',
      'geometry',
      'handwriting-exercise',
      'korean-english',
      'physics',
      'probability',
      'science',
      'science-trivia',
      'sentence-prompt',
      'time-distance-speed',
      'two-variable-algebra',
    ]);



    const decodeSignature = (params) => {
      const s = params.get('s');
      if (s) {
        return s.split(',').map((string) => Number(string));
      } else {
        return [];
      }
    };

    const params = new URLSearchParams(document.location.search);
    const s = decodeSignature(params);

    const chooseProblem = (chosen, problems) => {
      if (s.length > 0) {
        const id = s.shift();
        for (const problem of problems) {
          if (problem.id === id) {
            return problem;
          }
        }
      }
      let seen = 0;
      let chosenProblem;
      for (const problem of problems) {
        if (chosen.has(problem) || !kEligibleGenerators.has(problem.generator)) {
          continue;
        }
        if (problem.todo) {
          if (problem.todo === 'fix' || problem.todo.include('fix')) {
            continue;
          }
        }
        seen += 1;
        if (Math.random() * seen <= 1) {
          chosenProblem = problem;
        }
      }
      return chosenProblem;
    }

    const chosen = new Set();

    const signature = [];

    const renderColumn = (column) => {
      for (let nth = 0; nth < 10; nth++) {
        const problem = chooseProblem(chosen, problems);
        const e = renderProblem(problem);
        column.appendChild(e);
        signature.push(problem.id);
        chosen.add(problem);
        e.addEventListener('click', async () => {
          const note = await loadNote(problem.id);
          if (note.count === undefined) {
            note.count = 0;
          }
          note.count++;
          await saveNote(problem.id, note);
          alert(JSON.stringify(note));
        });
      }
    };

    const left = document.getElementById('left');
    const right = document.getElementById('right');

    renderColumn(left);
    renderColumn(right);

    {
      const payload = `https://jsxcad.js.org/math/q.html?s=${signature.join(',')}`;
      const qr = qrcodegen.QrCode.encodeText(payload, qrcodegen.QrCode.Ecc.MEDIUM);

      const toSvgString = (qr, border, lightColor, darkColor) => {
        if (border < 0)
            throw new RangeError("Border must be non-negative");
        let parts = [];
        for (let y = 0; y < qr.size; y++) {
            for (let x = 0; x < qr.size; x++) {
                if (qr.getModule(x, y))
                    parts.push(`M${x + border},${y + border}h1v1h-1z`);
            }
        }
        return `
          <svg width="64" height="64" viewBox="0 0 ${qr.size + border * 2} ${qr.size + border * 2}" stroke="none">
	    <rect width="100%" height="100%" fill="${lightColor}"/>
	    <path d="${parts.join(" ")}" fill="${darkColor}"/>
          </svg>`;
      };
      const svgText = toSvgString(qr, 5, 'white', 'black');
      const div = document.createElement('div');
      div.innerHTML = svgText;
      const svg = div.firstChild.nextSibling;
      const firstPassage = right.firstChild.nextSibling;
      firstPassage.insertBefore(svg, firstPassage.firstChild);
      svg.style.float = 'right';
      svg.style.zIndex = 10;
      svg.onclick = (e) => { window.location = payload; };
    }

    while (!MathJax.startup) {
      await new Promise(resolve => setTimeout(resolve, 10)); // Wait 10ms
    }

    await MathJax.startup.promise;
    await MathJax.typesetPromise();

  </script>
 </body>
</html>
